# Copyright (C) Deutsche Telekom AG
#
# Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
#
# 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
#
"""NETCONF client
"""

import logging
import net
import process
import testing
import xml

from buffer import Buffer, IncompleteReadError
import ssh_client

SEPARATOR_FRAMING: int = 0
CHUNKED_FRAMING: int = 1

CHUNK_SIZE_MAX: int = 4294967295

LEGACY_SEPARATOR: bytes = "]]>]]>".encode()

CHUNK_TAG_PREFIX: bytes = "\n#".encode()
CHUNK_TAG_END_OF_MSG: bytes = "#".encode()
CHUNK_TAG_POSTFIX: bytes = "\n".encode()

CAP_NC_1_1 = "urn:ietf:params:netconf:base:1.1"

NS_NC_1_0 = "urn:ietf:params:xml:ns:netconf:base:1.0"
NS_YANG_ACTION = "urn:ietf:params:xml:ns:yang:1"

# TODO: I think this should be in __builtin__
class UnreachableError(Exception):
    pass

# TODO: move these to __builtin__
class ConnectionError(OSError):
    pass

class BrokenPipeError(ConnectionError):
    pass

class ConnectionAbortedError(ConnectionError):
    pass

class ConnectionRefusedError(ConnectionError):
    pass

class ConnectionResetError(ConnectionError):
    pass


class NetconfError(Exception):
    def __init__(self, error_message: ?str, rpc_error: ?list[RpcError]):
        self.error_message = error_message if error_message is not None else ""
        self.rpc_error = rpc_error

    def __str__(self):
        return "{self._name()}: {self.error_message.strip()}"

    def __repr__(self):
        return "{self._name()}({repr(self.error_message)}, {repr(self.rpc_error)})"


class RpcError(object):
    # RFC 6241 rpc-error fields
    error_type: str         # transport/rpc/protocol/application
    error_tag: str          # in-use/invalid-value/too-big/etc.
    error_severity: str     # error/warning
    error_app_tag: ?str     # optional application-specific tag
    error_path: ?str        # optional XPath/element path
    error_message: ?str     # optional human-readable message
    error_info: ?dict[str, str]  # optional additional error information
    xml: xml.Node          # raw <rpc-error> XML, including any vendor extension elements

    def __init__(self, xml_node: xml.Node):
        # Initialize all attributes before any references to self escape
        self.xml = xml_node
        self.error_type = ""  # Will be set from XML, required field
        self.error_tag = ""   # Will be set from XML, required field
        self.error_severity = ""  # Will be set from XML, required field
        self.error_app_tag = None
        self.error_path = None
        self.error_message = None
        self.error_info = None

        def expect(t, errmsg):
            if t is not None:
                return t
            raise ValueError(errmsg)

        # Parse the XML into well-known attributes
        for child in xml_node.children:
            if child.tag == "error-type":
                self.error_type = expect(child.text, "rpc-error missing expected error-type")
            elif child.tag == "error-tag":
                self.error_tag = expect(child.text, "rpc-error missing expected error-tag")
            elif child.tag == "error-severity":
                self.error_severity = expect(child.text, "rpc-error missing expected error-severity")
            elif child.tag == "error-app-tag":
                self.error_app_tag = child.text
            elif child.tag == "error-path":
                self.error_path = child.text
            elif child.tag == "error-message":
                self.error_message = child.text
            elif child.tag == "error-info":
                # Parse error-info elements into a dictionary
                info = {}
                for info_child in child.children:
                    info_child_text = info_child.text
                    if info_child_text is not None:
                        info[info_child.tag] = info_child_text
                if len(info) > 0:
                    self.error_info = info

    def __repr__(self):
        args = "error_type={repr(self.error_type)}"
        args += ", error_tag={repr(self.error_tag)}"
        args += ", error_severity={repr(self.error_severity)}"
        if self.error_app_tag is not None:
            args += ", error_app_tag={repr(self.error_app_tag)}"
        if self.error_path is not None:
            args += ", error_path={repr(self.error_path)}"
        if self.error_message is not None:
            args += ", error_message={repr(self.error_message)}"
        if self.error_info is not None:
            args += ", error_info={repr(self.error_info)}"

        return "netconf.RpcError({args})"


STATE_NONE          = 0
STATE_CONNECTING    = 1
STATE_CONNECTED     = 2
STATE_DISCONNECTING = 3

state_name = {
    STATE_NONE:          "none",
    STATE_CONNECTING:    "connecting",
    STATE_CONNECTED:     "connected",
    STATE_DISCONNECTING: "disconnecting"
}

actor Client(
        auth: WorldCap,
        address: str,
        port: int,
        username: str,
        password: ?str,
        key: ?str,
        on_connect: action(Client, ?Exception) -> None,
        on_notif: ?action(Client, xml.Node) -> None,
        skip_host_key_check: bool=False,
        log_handler: ?logging.Handler):

    _log = logging.Logger(log_handler)
    _log.info("Connecting to " + address + ":" + str(port) + " as " + username)

    var framing = SEPARATOR_FRAMING
    var recv_buf = Buffer()
    var chunk_buf = Buffer()

    var session_id: ?str = None
    var capabilities: list[str] = []

    # Tracks explicit namespace prefix used in NETCONF messages. To maximize
    # compatibility, we track and mirror the same namespace prefix declaration
    # pattern used by the server. The default is to not use any prefix and set
    # the xmlns default namespace on the root element. If we a prefix used in a
    # server response, we switch over to use an explicit prefix on all elements,
    # including attributes.
    #
    # The NETCONF RFC 6241 allows for any valid XML encoding to be used, but
    # real world experience has shown that some implementations are sensitive.
    # By dynamically aligning on what we detect the remote end is doing, we
    # maximize our chances of interoperability.
    #
    # For examples JUNOS with rfc-compliant mode [1] enabled will NOT include
    # the message-id in rpc-reply if the message-id attribute in the rpc is sent
    # without an explicit namespace prefix.
    #
    # We always use the "urn:ietf:params:xml:ns:netconf:base:1.0" namespace when
    # creating xml.Node for tags. The nsdefs tuple (nc_prefix, NS_NC_1_1)
    # renders to either the default or explicit namespace declaration depending
    # nc_prefix.
    #
    # [1]: (https://www.juniper.net/documentation/us/en/software/junos/netconf/topics/concept/netconf-session-rfc-compliant.html)
    var nc_prefix: ?str = None

    var message_id = 1
    var rpc_cbs: list[(id: str, cb: action(Client, ?xml.Node, ?NetconfError) -> None)] = []

    var c: ?ssh_client.Client = None
    var state = STATE_NONE

    def _parse_rpc_errors(rpc_reply: xml.Node) -> ?NetconfError:
        """Parse <rpc-error> elements from an rpc-reply and return NetconfError if found"""
        errors = []
        for child in rpc_reply.children:
            if child.tag == "rpc-error":
                errors.append(RpcError(child))

        if len(errors) == 0:
            return None
        else:
            # Construct error message summary
            messages = []
            for err in errors:
                error_message = err.error_message
                if error_message is not None:
                    messages.append(error_message)
            error_message = "; ".join(messages) if len(messages) > 0 else None
            return NetconfError(error_message, errors)

    def get_capabilities() -> list[str]:
        return capabilities

    # TODO: Close protocol
    def close(cb: ?action() -> None) -> None:
        for rpc_cb in rpc_cbs:
            rpc_cb.cb(self, None, None)
        rpc_cbs.clear()

        if c is not None:
            c.close(cb)
        else:
            if cb is not None:
                cb()

    # TODO: Restart protocol
    def restart() -> None:
        _log.info("Restarting")
        for rpc_cb in rpc_cbs:
            rpc_cb.cb(self, None, None)

        framing = SEPARATOR_FRAMING
        recv_buf = Buffer()
        chunk_buf = Buffer()

        session_id = None
        capabilities = []

        message_id = 1
        rpc_cbs.clear()

        state = STATE_NONE

        if c is not None:
            c.restart()
        else:
            _log.warning("Cannot restart, SSH client is not running")

    def _send_message(data: Buffer) -> None:
        if c is not None:
            if framing == SEPARATOR_FRAMING:
                data.write_bytes(LEGACY_SEPARATOR)
                _msg = data.read_all_bytes()
                _log.trace("Sending message", {"msg": _msg})
                c.write(_msg)
            elif framing == CHUNKED_FRAMING:
                while True:
                    chunk_size = CHUNK_SIZE_MAX if data.unread_bytes > CHUNK_SIZE_MAX else data.unread_bytes
                    if chunk_size <= 0:
                        c.write("\n##\n".encode())
                        break

                    _chunk = data.read_bytes(chunk_size)
                    _log.trace("Sending chunk", {"chunk_size": chunk_size, "chunk": _chunk})
                    c.write(("\n#" + str(chunk_size) + "\n").encode())
                    c.write(_chunk)
        else:
            on_connect(self, BrokenPipeError("Cannot send message, SSH process is not running"))

    def rpc(content: xml.Node, callback: action(Client, ?xml.Node, ?NetconfError) -> None) -> None:
        message_id_text = str(message_id)
        message_id += 1

        # If using an explicit namespace prefix, prepend it to the attribute name.
        # The namespace (prefix or not) is defined in the tag.
        if nc_prefix is not None:
            rpc_attrs = [(nc_prefix + ":message-id", message_id_text)]
        else:
            rpc_attrs = [("message-id", message_id_text)]

        root = xml.Node("rpc", [(nc_prefix, NS_NC_1_0)], nc_prefix, rpc_attrs, [content])

        buf: Buffer = Buffer()
        buf.write_str(xml.encode(root))

        rpc_cbs.append((id=message_id_text, cb=callback))
        _log.debug("Sending RPC", {"message-id": message_id_text, "content": content})
        _send_message(buf)

    def get(cb: action(Client, ?xml.Node, ?NetconfError) -> None, filter: ?xml.Node=None) -> None:
        _log.info("NETCONF get")
        nc_nsdefs = [(None, NS_NC_1_0)]
        children = []
        if filter is not None:
            children.append(filter)
        rpc(xml.Node("get", nc_nsdefs, children=children), cb)

    def get_config(cb: action(Client, ?xml.Node, ?NetconfError) -> None, datastore: str="running", filter: ?xml.Node=None) -> None:
        _log.info("NETCONF get-config")
        nc_nsdefs = [(nc_prefix, NS_NC_1_0)]
        children = [
            xml.Node("source", [], nc_prefix, children=[
                xml.Node(datastore, [], nc_prefix)
            ])
        ]
        if filter is not None:
            children.append(filter)
        rpc(xml.Node("get-config", nc_nsdefs, nc_prefix, children=children), cb)

    def edit_config(config: str, cb: action(Client, ?NetconfError) -> None, datastore: str="running", default_operation: ?str=None) -> None:
        _log.info("NETCONF edit-config", {"datastore": datastore, "default-operation": default_operation})
        nc_nsdefs = [(nc_prefix, NS_NC_1_0)]
        # Decode the config XML string into xml.Node objects to preserve
        # structure. Direct assignment to text attribute of the <config> node
        # would escape special characters, breaking the XML. We wrap the config
        # in <data> tags for parsing because there the config is likely to
        # contain multiple top-level nodes, then use only the children.
        # TODO: this is not very efficient as we decode the XML string to
        # xml.Node only to encode the RPC document again right away.
        config_xml = xml.decode("<data>{config}</data>")
        edit_config_children = [
            xml.Node("target", [], nc_prefix, children=[
                xml.Node(datastore, [], nc_prefix)
            ])
        ]
        if default_operation is not None:
            if default_operation not in {"merge", "replace", "none"}:
                raise ValueError("Invalid default-operation: {default_operation}")
            edit_config_children.append(xml.Node("default-operation", text=default_operation))
        # Define "xc" namespace prefix for NETCONF operation attributes.
        # Cisco IOS XRd requires namespace declaration on an ancestor node,
        # not just where operation attributes are used.
        edit_config_children.append(xml.Node("config", [("xc", "urn:ietf:params:xml:ns:netconf:base:1.0")], nc_prefix, children=config_xml.children))
        rpc(xml.Node("edit-config", nc_nsdefs, nc_prefix, children=edit_config_children), lambda c, _, err: cb(c, err))

    def commit(cb: action(Client, ?NetconfError) -> None) -> None:
        _log.info("NETCONF commit", {})
        nc_nsdefs = [(nc_prefix, NS_NC_1_0)]
        rpc(xml.Node("commit", nc_nsdefs, nc_prefix), lambda c, _, err: cb(c, err))

    def discard_changes(cb: action(Client, ?NetconfError) -> None) -> None:
        _log.info("NETCONF discard-changes", {})
        nc_nsdefs = [(nc_prefix, NS_NC_1_0)]
        rpc(xml.Node("discard-changes", nc_nsdefs, nc_prefix), lambda c, _, err: cb(c, err))

    def lock(cb: action(Client, ?NetconfError) -> None, datastore: str) -> None:
        _log.info("NETCONF lock", {"datastore": datastore})
        nc_nsdefs = [(nc_prefix, NS_NC_1_0)]
        rpc(xml.Node("lock", nc_nsdefs, nc_prefix, children=[
            xml.Node("target", [], nc_prefix, children=[
                xml.Node(datastore, [], nc_prefix)
            ])
        ]), lambda c, _, err: cb(c, err))

    def unlock(cb: action(Client, ?NetconfError) -> None, datastore: str) -> None:
        _log.info("NETCONF unlock", {"datastore": datastore})
        nc_nsdefs = [(nc_prefix, NS_NC_1_0)]
        rpc(xml.Node("unlock", nc_nsdefs, nc_prefix, children=[
            xml.Node("target", [], nc_prefix, children=[
                xml.Node(datastore, [], nc_prefix)
            ])
        ]), lambda c, _, err: cb(c, err))

    def get_schema(cb: action(Client, ?xml.Node, ?NetconfError) -> None, identifier: str, version: ?str=None, format: str="yang") -> None:
        _log.info("NETCONF get-schema", {"identifier": identifier, "version": version, "format": format})
        # get-schema is part of ietf-netconf-monitoring, not base NETCONF
        nc_nsdefs = [(None, "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring")]
        children = [xml.Node("identifier", text=identifier)]
        if version is not None:
            children.append(xml.Node("version", text=version))
        children.append(xml.Node("format", text=format))
        rpc(xml.Node("get-schema", nc_nsdefs, children=children), cb)

    def list_schemas(cb: action(Client, list[(identifier: str, namespace: str, version: str, format: str)], ?NetconfError) -> None) -> None:
        """List available schemas and return parsed list of (identifier, version, format) tuples"""
        _log.info("NETCONF list-schemas")

        def _parse_response(c: Client, result: ?xml.Node, error: ?NetconfError):
            schemas = []
            if error is not None:
                # Pass empty list if there are errors
                cb(c, schemas, error)
            elif result is not None:
                if result.tag == "rpc-reply":
                    for child in result.children:
                        if child.tag == "data":
                            schemas = _parse_schemas_data(child)
            cb(c, schemas, None)

        def _parse_schemas_data(data_node: xml.Node) -> list[(str, str, str, str)]:
            schemas = []
            for netconf_state in data_node.children:
                if netconf_state.tag == "netconf-state":
                    for schemas_node in netconf_state.children:
                        if schemas_node.tag == "schemas":
                            for schema in schemas_node.children:
                                if schema.tag == "schema":
                                    identifier = None
                                    namespace = None
                                    version = None
                                    format = None
                                    for attr in schema.children:
                                        attr_text = attr.text
                                        if attr.tag == "identifier" and attr_text is not None:
                                            identifier = attr_text
                                        elif attr.tag == "namespace" and attr_text is not None:
                                            namespace = attr_text
                                        elif attr.tag == "version" and attr_text is not None:
                                            version = attr_text
                                        elif attr.tag == "format" and attr_text is not None:
                                            format = attr_text
                                    if identifier is not None and namespace is not None and version is not None and format is not None:
                                        schemas.append((identifier, namespace, version, format))
            return schemas

        # Create filter for /netconf-state/schemas from ietf-netconf-monitoring
        filter_node = xml.Node("filter", None, None, [("type", "subtree")], [
            xml.Node("netconf-state",
                [(None, "urn:ietf:params:xml:ns:yang:ietf-netconf-monitoring")],
                children=[xml.Node("schemas")]
            )
        ], None, None)
        get(_parse_response, filter_node)

    def rpc_action(content: xml.Node, callback: action(Client, ?xml.Node, ?NetconfError) -> None) -> None:
        action_node = xml.Node("action", [(None, NS_YANG_ACTION)], None, [], [content], None, None)
        rpc(action_node, callback)

    def _send_hello() -> None:
        hello = """<?xml version="1.0" encoding="UTF-8"?>
        <hello xmlns="urn:ietf:params:xml:ns:netconf:base:1.0">
            <capabilities>
                <capability>urn:ietf:params:netconf:base:1.0</capability>
                <capability>urn:ietf:params:netconf:base:1.1</capability>
            </capabilities>
        </hello>"""
        buf: Buffer = Buffer()
        buf.write_str(hello)
        _send_message(buf)

    def handle_msg(msg: str) -> None:
        if len(msg) == 0:
            _log.debug("Ignoring empty message")
            return
        _log.trace("MSG:", {"msg": msg})
        try:
            root = xml.decode(msg)

            # Detect/update namespace prefix mode from server messages
            root_prefix = root.prefix
            if root_prefix is not None and root_prefix != nc_prefix:
                if nc_prefix is None:
                    _log.info("Server switched to explict namespace prefix mode", {"prefix": root_prefix})
                else:
                    _log.info("Explicit namespace prefix changed", {"previous": nc_prefix, "new": root_prefix})
                nc_prefix = root_prefix
            elif root_prefix is None and nc_prefix is not None:
                _log.info("Server switched to implicit namespace mode")
                nc_prefix = None

            if root.tag == "notification": # TODO: check namespace as well?
                _on_msg_notification(root)
            elif root.tag == "rpc-reply": # TODO: check namespace as well?
                _on_msg_rpc_reply(root)
            elif root.tag == "hello": # TODO: check namespace as well?
                _on_msg_hello(root)
            else:
                _log.warning("Unhandled message type:", {"root.tag": root.tag})
        except Exception as exc:
            _log.error("Failed to parse XML", {"msg": msg, "exc": exc})
            # TODO: I think we need to disconnect and start over, no?

    def _on_msg_hello(root: xml.Node) -> None:
        for n in root.children:
            if n.tag == "capabilities": # TODO: check namespace as well?
                capabilities.clear()
                for cap in n.children:
                    if cap.tag == "capability": # TODO: check namespace as well?
                        cap_body = cap.text # cap_body = cap.text.strip()
                        _on_capability(cap)
                    else:
                        pass # TODO: Warn?
            elif n.tag == "session-id": # TODO: check namespace as well?
                session_id = n.text
        state = "CONNECTED"
        on_connect(self, None)

    def _on_capability(cap: xml.Node) -> None:
        cap_text = cap.text # cap_text = cap.text.strip()
        if cap_text is not None:
            capabilities.append(cap_text)
            if cap_text == CAP_NC_1_1:
                _log.debug("NETCONF 1.1 supported, switching to chunked framing")
                framing = CHUNKED_FRAMING

    def _on_msg_rpc_reply(root: xml.Node) -> None:
        msg_id: ?str = None
        for attr_name, attr_val in root.attributes:
            # Handle both "message-id" and "nc:message-id" attributes
            if attr_name == "message-id" or attr_name == "nc:message-id":
                msg_id = attr_val
                break
            # Also handle other potential namespace prefixes
            elif attr_name.split(":", -1)[-1] == "message-id":
                msg_id = attr_val
                break

        if len(rpc_cbs) > 0:
            cb = rpc_cbs.pop(0)
            if msg_id is None:
                _log.warning("Received invalid rpc-reply, missing message-id", {"msg": root.encode()})
            elif msg_id is not None and msg_id != cb.id:
                _log.warning("Received rpc-reply with unexpected message-id", {"msg-id": msg_id, "cb.id": cb.id})

            if len(root.children) == 0:
                cb.cb(self, root, NetconfError("Empty <rpc-reply>"))
            elif len(root.children) == 1 and root.children[0].tag == "ok":
                # TODO: Should also verify namespace is NS_NC_1_0
                cb.cb(self, root, None)
            else:
                # Parse for errors
                error = _parse_rpc_errors(root)

                if error is not None:
                    # Error response
                    cb.cb(self, root, error)
                else:
                    # Normal data response - pass the whole root
                    cb.cb(self, root, None)
        else:
            _log.error("No more RPC callbacks", {"msg-id": msg_id})



    def _on_msg_notification(root: xml.Node) -> None:
        _on_notif = on_notif
        if _on_notif is not None:
            _on_notif(self, root)

    def _on_legacy_msg_data() -> bool:
        i = recv_buf.find_bytes(LEGACY_SEPARATOR)
        if isinstance(i, int):
            _msg_data = recv_buf.read_bytes(i)
            if isinstance(_msg_data, bytes):
                recv_buf.skip_bytes(len(LEGACY_SEPARATOR))
                recv_buf.consume()
                handle_msg(_msg_data.decode())
                return True
        recv_buf.rewind()
        return False

    def _on_chunked_msg_data() -> bool:
        m = recv_buf.match_bytes(CHUNK_TAG_PREFIX)
        if isinstance(m, IncompleteReadError):
            recv_buf.rewind()
            return False
        elif isinstance(m, bool):
            if not m:
                on_connect(self, NetconfError("Invalid chunk framing data"))
                return False
            _len_text_len = recv_buf.find_bytes(CHUNK_TAG_POSTFIX)
            if isinstance(_len_text_len, IncompleteReadError):
                recv_buf.rewind()
                return False
            elif isinstance(_len_text_len, int):
                _len_text = recv_buf.read_bytes(_len_text_len)

                _skip = recv_buf.skip_bytes(len(CHUNK_TAG_POSTFIX))
                if isinstance(_skip, IncompleteReadError):
                    recv_buf.rewind()
                    return False
                elif isinstance(_skip, bool) and _skip:
                    if isinstance(_len_text, bytes):
                        if _len_text == CHUNK_TAG_END_OF_MSG:
                            _msg_data = chunk_buf.read_all_bytes()
                            chunk_buf.consume()
                            handle_msg(_msg_data.decode())
                            return True
                        else:
                            try:
                                l = int(_len_text.decode())
                                chunk = recv_buf.read_bytes(l)
                                chunk_buf.write_bytes(chunk)
                                recv_buf.consume()
                                return True
                            except IncompleteReadError:
                                recv_buf.rewind()
                                return False
        # TODO: FIXME: match_bytes should always return bytes or raise exception
        raise UnreachableError("Unexpected state in _on_chunked_msg_data")

    def _on_receive(c, data: bytes):
        #_log.trace("DATA:", {"data": data})
        recv_buf.write_bytes(data)
        try_read: bool = True
        # while recv_buf.has_unread_bytes() and try_read: # actonc: Name try_read is not in scope
        while recv_buf.has_unread_bytes():
            if not try_read:
                break
            if framing == SEPARATOR_FRAMING:
                try_read = _on_legacy_msg_data()
            elif framing == CHUNKED_FRAMING:
                try_read = _on_chunked_msg_data()
            else:
                try_read = False
                on_connect(self, NetconfError("Unknown framing type: {framing}"))

    def _on_connect(c, err: ?Exception):
        if err is not None:
            _log.error("Failed to connect", {"err": err})
            on_connect(self, err)
        else:
            _log.info("Connected", {"address": address, "port": port, "username": username})
            state = STATE_CONNECTED
            _send_hello()

    def _connect():
        c = ssh_client.Client(auth,
                              on_connect=_on_connect,
                              on_receive=_on_receive,
                              address=address,
                              username=username,
                              key=None,
                              password=password,
                              port=port,
                              subsystem="netconf",
                              skip_host_key_check=skip_host_key_check,
                              log_handler=log_handler)

    _connect()

class NsMaps(object):
    def __init__(self, namespaces: list[(?str, str)], parent: ?NsMaps):
        self.nsmap = {_prefix if _prefix is not None else "": _ns for _prefix, _ns in namespaces}
        self.parent = parent

    def lookup(self, prefix: ?str) -> ?str:
        _inst = self
        while True:
            ns: ?str = self.nsmap.get(prefix if prefix is not None else "")
            if ns is not None:
                return ns
            _parent = _inst.parent
            if _parent is not None:
                _inst = _parent
            else:
                return None


actor SchemaGetter(client):
    """Helper actor for downloading schemas from NETCONF server."""

    def download(on_get_schema: action(int, int, (identifier: str, namespace: ?str, version: ?str, format: str), ?str, ?NetconfError) -> None, on_done: action(?NetconfError) -> None, identifier_str: str):
        """Download schemas from a NETCONF server.

        Download one or more schemas from NETCONF server with <get-schema>.
        Supports downloading either a specific schema by identifier or all
        available schemas when 'all' is specified.

        Args:
            on_get_schema: Callback invoked for each schema download. Parameters:
                - current_index (int): index of current schema being downloaded
                - total_count (int): Total number of schemas to download
                - schema_id: (identifier, ?namespace, ?version, format)
                - schema_data (?str): Schema content if successful, None on error
                - error (?NetconfError): None if successful, error details if failed
            on_done: Callback invoked when all downloads complete. Parameter:
                - error (?NetconfError): None if successful, error details if failed
            identifier_str: Schema identifier to download, or 'all' to download all available schemas
        """
        schemas_to_download: list[(identifier: str, namespace: ?str, version: ?str, format: str)] = []
        current_download_index = 0

        def _on_list_schemas(c: Client, schemas: list[(identifier: str, namespace: str, version: str, format: str)], error: ?NetconfError):
            """Handle schema list response"""
            if error is not None:
                on_done(error)
                return

            # Only download yang format (not yin) to avoid duplicates
            for schema in schemas:
                if schema.format == "yang":
                    schemas_to_download.append((identifier=schema.identifier, namespace=schema.namespace, version=schema.version, format=schema.format))

            _download_next_schema()

        def _download_next_schema():
            """Download the next schema in the queue"""
            if current_download_index >= len(schemas_to_download):
                # All schemas downloaded successfully
                on_done()
                return
            schema = schemas_to_download[current_download_index]

            # Use "yang" as default format if not specified
            format_str = schema.format if schema.format is not None else "yang"
            client.get_schema(_on_get_schema, schema.identifier, schema.version, format_str)

        def _on_get_schema(c: Client, result: ?xml.Node, error: ?NetconfError):
            """Handle individual schema response"""
            schema = schemas_to_download[current_download_index]
            if error is not None:
                on_get_schema(current_download_index+1, len(schemas_to_download), schema, None, error)
            else:
                # Extract schema data
                schema_data = None
                if result is not None:
                    for child in result.children:
                        if child.tag == "data":
                            schema_data = child.text
                            break

                # Call the callback with current progress and schema data
                if schema_data is not None:
                    on_get_schema(current_download_index+1, len(schemas_to_download), schema, schema_data)
                else:
                    on_get_schema(current_download_index+1, len(schemas_to_download), schema, None, NetconfError("Missing schema data"))

            # Move to next schema
            current_download_index += 1
            _download_next_schema()

        if identifier_str == "all":
            # Get list of all schemas first
            client.list_schemas(_on_list_schemas)
        else:
            # Download single schema
            schemas_to_download.append((identifier=identifier_str, namespace=None, version=None, format="yang"))
            _download_next_schema()


################################################################################
## Tests                                                                      ##
################################################################################
#
# These test cases can be run with `acton test` but they require a running SSH
# server, for example `docker run -td -P ghcr.io/notconf/notconf` - grab the
# port and update test_port below, i.e.:
# - docker run -td --name notconf -P ghcr.io/notconf/notconf
# - docker inspect notconf | jq -r '.[0].NetworkSettings.Ports["830/tcp"][0].HostPort'
# - update test_port below with the port from the above command
# - acton test

test_port = 42830
test_address = "localhost"
test_username = "admin"
test_password = "admin"


actor _test_netconf(t: testing.EnvT):
    """Test SSH client towards a NETCONF server, like notconf
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            for cap in c.get_capabilities():
                if cap.startswith("urn:ietf:params:netconf:base:1"):
                    log.info("Got NETCONF {cap} capability, looks reasonable, hello success")
                    c.get_config(_on_get_config)

    def _on_get_config(c: Client, result: ?xml.Node, error: ?NetconfError):
        if error is not None:
            log.error("<get-config> failed", {"error": error})
            t.failure(ValueError("get-config failed with error"))
        else:
            log.info("<get-config> success")
            t.success()

    c = Client(t.env.auth,
                on_connect=_on_connect,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                on_notif=None,
                skip_host_key_check=True,
                log_handler=t.log_handler)


actor _test_get_schema(t: testing.EnvT):
    """Test SSH client get-schema operation towards a NETCONF server
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            for cap in c.get_capabilities():
                if cap.startswith("urn:ietf:params:netconf:base:1"):
                    log.info("Got NETCONF {cap} capability, looks reasonable, hello success")
                    c.get_schema(_on_get_schema, "ietf-netconf")

    def _on_get_schema(c: Client, result: ?xml.Node, error: ?NetconfError):
        if error is not None:
            log.error("<get-schema> failed", {"error": error})
            t.failure(ValueError("get-schema failed with error"))
        elif result is not None:
            log.info("<get-schema> received response", {"result": result})
            t.success()
        else:
            log.error("<get-schema> received null response")
            t.failure(ValueError("get-schema returned null"))

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_notif=None,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)


actor _test_list_schemas(t: testing.EnvT):
    """Test listing available schemas from a NETCONF server
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            c.list_schemas(_on_list_schemas)

    def _on_list_schemas(c: Client, schemas: list[(identifier: ?str, namespace: ?str, version: ?str, format: ?str)], error: ?NetconfError):
        if error is not None:
            log.error("<list-schemas> failed", {"error": error})
            t.failure(ValueError("list-schemas failed with error"))
        else:
            log.info("Received schemas list", {"count": len(schemas)})
            for schema in schemas:
                log.info("Schema found", {"identifier": schema.identifier, "namespace": schema.namespace, "version": schema.version, "format": schema.format})
            if len(schemas) > 0:
                t.success()
            else:
                log.warning("No schemas found")
                t.success()  # Still success even if no schemas

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_notif=None,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)


actor _test_schema_getter(t: testing.EnvT):
    """Test listing available schemas from a NETCONF server
    """
    log = logging.Logger(t.log_handler)
    expected = 0
    count = 0

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            sg = SchemaGetter(c)
            sg.download(_on_schema_download, _on_download_complete, "all")

    def _on_schema_download(index: int, total: int, schema_id: (identifier: str, namespace: ?str, version: ?str, format: str), schema_data, error):
        expected = total
        log.debug("Download {index}/{total} {schema_id.identifier}")
        if error is not None:
            t.failure(Exception("{schema_id.identifier}: {error}"))
        elif schema_data is None:
            t.failure(Exception("{schema_id.identifier}: empty"))
        else:
            count += 1

    def _on_download_complete(error):
        if count != expected:
            t.failure(ValueError("Incorrect count: {count} != {expected}"))
        elif error is not None:
            t.failure(error)
        else:
            t.success()

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_notif=None,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)


actor _test_lock_unlock(t: testing.EnvT):
    """Test lock and unlock operations on a datastore
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            c.lock(_on_lock, "candidate")

    def _on_lock(c: Client, error: ?NetconfError):
        if error is not None:
            log.error("Lock operation failed", {"error": error})
            t.failure(ValueError("Lock operation failed with error"))
        else:
            log.info("Lock operation successful")
            # Now unlock the datastore
            c.unlock(_on_unlock, "candidate")

    def _on_unlock(c: Client, error: ?NetconfError):
        if error is not None:
            log.error("Unlock operation failed", {"error": error})
            t.failure(ValueError("Unlock operation failed with error"))
        else:
            log.info("Unlock operation successful")
            log.info("Lock and unlock test completed successfully")
            t.success()

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_notif=None,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)


actor _test_get_config_with_filter(t: testing.EnvT):
    """Test get-config operation with a subtree filter
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            # Create a subtree filter to get only specific configuration
            # Example: filter for interfaces configuration
            filter_node = xml.Node("filter", None, None, [("type", "subtree")], [
                xml.Node("interfaces",
                    [(None, "urn:ietf:params:xml:ns:yang:ietf-interfaces")],
                    children=[
                        xml.Node("interface", children=[
                            xml.Node("name", text="eth0")
                        ])
                    ]
                )
            ])
            c.get_config(_on_get_config_filtered, "running", filter_node)

    def _on_get_config_filtered(c: Client, result: ?xml.Node, error: ?NetconfError):
        if error is not None:
            log.error("<get-config> with filter failed", {"error": error})
            t.failure(ValueError("get-config with filter failed with error"))
        elif result is not None:
            log.info("<get-config> with filter received response")
            # Check if we got an rpc-reply
            if result.tag == "rpc-reply":
                # For successful get-config, there should be a single <data> element
                if len(result.children) > 0 and result.children[0].tag == "data":
                    log.info("Filtered config data received successfully")
                    t.success()
                else:
                    log.warning("No data element in response, but this might be normal if no matching config exists")
                    t.success()  # Still success as empty result is valid for filter
            else:
                log.error("Unexpected response type", {"tag": result.tag})
                t.failure(ValueError("Unexpected response type: {result.tag}"))
        else:
            log.error("<get-config> with filter received null response")
            t.failure(ValueError("get-config with filter returned null"))

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_notif=None,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)


actor _test_get_config_with_xpath_filter(t: testing.EnvT):
    """Test get-config operation with an XPath filter
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            # Create an XPath filter to select specific configuration elements
            # Example: select all interface names
            filter_node = xml.Node("filter", None, None,
                [("type", "xpath"),
                 ("select", "/interfaces/interface/name")],
                []
            )
            c.get_config(_on_get_config_xpath_filtered, "running", filter_node)

    def _on_get_config_xpath_filtered(c: Client, result: ?xml.Node, error: ?NetconfError):
        if error is not None:
            # XPath might not be supported, which is ok
            log.info("Server returned error (XPath might not be supported)", {"error": error})
            t.success()  # Still consider it success if XPath is not supported
        elif result is not None:
            log.info("<get-config> with XPath filter received response")
            # Check if we got an rpc-reply
            if result.tag == "rpc-reply":
                # For successful get-config, there should be a single <data> element
                if len(result.children) > 0 and result.children[0].tag == "data":
                    log.info("XPath filtered config data received successfully")
                    t.success()
                else:
                    log.warning("No data element in response")
                    t.success()  # Still success as empty result is valid
            else:
                log.error("Unexpected response type", {"tag": result.tag})
                t.failure(ValueError("Unexpected response type: {result.tag}"))
        else:
            log.error("<get-config> with XPath filter received null response")
            t.failure(ValueError("get-config with XPath filter returned null"))

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_notif=None,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)


actor _test_rpc_error_repr(t: testing.EnvT):
    """Test that NetconfError repr() works correctly with RPC errors

    This test intentionally triggers an RPC error by trying to lock a
    non-existent datastore, then verifies the repr() output.
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            log.error("Failed to connect", {"error": e})
            t.failure(ValueError("Failed to connect to NETCONF server: {e}"))
        else:
            log.info("Connected to NETCONF server")
            # Try to lock a non-existent datastore to trigger an error
            c.lock(_on_lock_error, "non-existent-datastore")

    def _on_lock_error(c: Client, error: ?NetconfError):
        if error is not None:
            log.info("Got expected error from invalid lock operation", {"error": error})
            t.success(repr(error))
        else:
            # We expected an error, but didn't get one
            log.error("Expected an error from invalid lock operation, but got success")
            t.failure(ValueError("Lock on non-existent datastore should have failed"))

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_notif=None,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)
