"""SSH client

This module implements an SSH client by running the `ssh` command line tool.
"""

import logging
import process
import testing

# TODO: move these to __builtin__
class ConnectionError(OSError):
    pass

class BrokenPipeError(ConnectionError):
    pass

class ConnectionAbortedError(ConnectionError):
    pass

class ConnectionRefusedError(ConnectionError):
    pass

class ConnectionResetError(ConnectionError):
    pass


STATE_NONE          = 0
STATE_CONNECTING    = 1
STATE_CONNECTED     = 2
STATE_DISCONNECTING = 3

state_name = {
    STATE_NONE:          "none",
    STATE_CONNECTING:    "connecting",
    STATE_CONNECTED:     "connected",
    STATE_DISCONNECTING: "disconnecting"
}

actor Client(auth: WorldCap,
             on_connect: action(Client, ?Exception) -> None,
             on_receive: action(Client, data: bytes) -> None,
             address: str,
             username: str,
             key: ?str,
             password: ?str,
             port: int=22,
             subsystem: ?str=None,
             skip_host_key_check: bool=False,
             log_handler: ?logging.Handler=None):
    _log = logging.Logger(log_handler)
    _log.info("Connecting", {"address": address, "username": username, "port": port})

    var p: ?process.Process = None
    var state = STATE_NONE

    var close_cb: ?action() -> None = None

    def get_state():
        """Get the current state of the SSH client"""
        return state

    # TODO: Close protocol
    def close(on_close: ?action() -> None=None):
        """Close the SSH client connection"""
        _log.debug("Closing SSH client")
        if state == STATE_DISCONNECTING:
            _log.debug("SSH client is already disconnecting")
            raise ValueError("SSH client is already disconnecting")

        close_cb = on_close

        if p is not None:
            _log.debug("Stopping SSH client process", {"pid": p.pid()})
            state = STATE_DISCONNECTING
            p.stop()
        else:
            _log.debug("SSH client already closed")
            if on_close is not None:
                _log.debug("Calling on_close callback")
                on_close()

    # TODO: Restart protocol
    def restart():
        _log.debug("Restarting SSH client...")
        if p is not None:
            pid = p.pid()
            if pid is not None:
                _log.debug("Existing SSH client process seems to be running, closing and then connecting")
                close(_connect)
            else:
                _log.debug("Existing SSH client process has no PID, connecting now")
                _connect()
        else:
            _log.debug("No existing SSH client process, connecting now")
            _connect()

    def write(data: bytes):
        if p is not None:
            p.write(data)
        else:
            raise ValueError("Unable to write, SSH client process not running")

    def _p_on_stderr(p, data: ?bytes):
        if data is not None:
            for line in data.splitlines():
                line = line.strip()
                _log.debug("SSH STDERR: {line}")
                if line == b"debug1: Connection established.":
                    state = STATE_CONNECTED
                    on_connect(self, None)

    def _p_on_stdout(p, data: ?bytes) -> None:
        if data is not None:
            on_receive(self, data)

    def _p_on_exit(p, exit_code, term_signal):
        _log.debug("SSH process exited", {"exit_code": exit_code, "term_signal": term_signal, "state": state_name[state]})
        exit_code_to_err_reason = {
            1: "Invalid command line argument",
            2: "Conflicting arguments given",
            3: "General runtime error",
            4: "Unrecognized response from ssh (parse error)",
            5: "Invalid/incorrect password",
            6: "Host public key is unknown. sshpass exits without confirming the new key.",
            7: "IP public key changed. sshpass exits without confirming the new key."
        }
        err_reason = exit_code_to_err_reason.get_def(exit_code, "Unknown error")
        if state == STATE_DISCONNECTING:
            _log.debug("SSH client process exited while disconnecting", {"exit_code": exit_code, "term_signal": term_signal, "err_reason": err_reason})
            if close_cb is not None:
                _log.debug("Calling close callback")
                close_cb()
            close_cb = None
        else:
            _log.info("SSH client process exited unexpectedly", {"exit_code": exit_code, "term_signal": term_signal, "err_reason": err_reason})
            on_connect(self, ConnectionError(err_reason))

        state = STATE_NONE
        p = None

    def _p_on_error(p, error):
        _log.debug("Error from process", {"error": error})
        on_connect(self, OSError(error))
        p = None

    def _connect():
        _log.debug("Connecting SSH client", {"address": address, "username": username, "port": port, "key": key, "password": password})
        if p is not None:
            _log.debug("SSH client process already created, stopping existing process")
            p.stop()

        cmd_env = None
        # Use -v for verbose output, we need this to determine e.g. connection established
        cmd = ["ssh", "-v", "-p", str(port), "-l", username]
        if skip_host_key_check:
            # Skip host key checking for testing environments
            cmd += ["-o", "StrictHostKeyChecking=no"]  # Disable strict host key checking
            cmd += ["-o", "UserKnownHostsFile=/dev/null"]  # Don't use known_hosts file
        if key is not None:
            cmd += ["-i", key]
        elif password is not None:
            cmd_env = {"SSHPASS": password}
            cmd.insert(0, "-e")
            cmd.insert(0, "sshpass")
        else:
            raise ValueError("Either key or password must be provided")
        cmd += [address]
        if subsystem is not None:
            cmd += ["-s", subsystem]
        _log.trace("CMD", {"cmd": cmd})

        state = STATE_CONNECTING
        p = process.Process(process.ProcessCap(auth), cmd, _p_on_stdout, _p_on_stderr, _p_on_exit, _p_on_error, env=cmd_env)

    _connect()


################################################################################
## Tests                                                                      ##
################################################################################
#
# These test cases can be run with `acton test` but they require a running SSH
# server, for example `docker run -td -P ghcr.io/notconf/notconf` - grab the
# port and update test_port below, i.e.:
# - docker run -td --name notconf -P ghcr.io/notconf/notconf
# - docker inspect notconf | jq -r '.[0].NetworkSettings.Ports["830/tcp"][0].HostPort'
# - update test_port below with the port from the above command
# - acton test

test_port = 42830
test_address = "localhost"
test_username = "admin"
test_password = "admin"

actor _test_bad_credentials(t: testing.EnvT):
    """Test SSH client with bad credentials
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        if e is not None:
            t.success()  # We expect a failure here
        else:
            t.failure(ValueError("Expected connection to fail with bad credentials, but it succeeded."))

    def _on_receive(c: Client, data: bytes):
        log.info("Received data: " + str(data))

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_receive=_on_receive,
                address=test_address,
                username="NON_EXISTING_USER",
                key=None,
                password="dummy",
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)

actor _test_netconf(t: testing.EnvT):
    """Test SSH client towards a NETCONF server, like notconf
    """
    log = logging.Logger(t.log_handler)

    def _on_connect(c: Client, e: ?Exception):
        pass

    def _on_receive(c: Client, data: bytes):
        log.info("Received data: " + str(data))
        if data.startswith(b"<hello"):
            log.info("Received NOTCONF hello message")
            # TODO: why is after necessary here?
            after 0.1: t.success()
        else:
            log.error("Received unexpected data: " + str(data))

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_receive=_on_receive,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)

actor _test_restart(t: testing.EnvT):
    """Test SSH client towards NOTCONF
    """
    log = logging.Logger(t.log_handler)

    var connects = 1

    def _on_connect(c: Client, e: ?Exception):
        log.info("Connected", {"connects": connects, "e": e})
        if connects == 1:
            log.info("Restarting..")
            c.restart()
        elif connects == 2:
            log.info("Success")
            t.success()

    def _on_receive(c: Client, data: bytes):
        log.info("Received data: " + str(data))

    c = Client(t.env.auth,
                on_connect=_on_connect,
                on_receive=_on_receive,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=t.log_handler)


# A test client, compile with: acton --root client src/ssh.act
actor client(env: Env):
    log_handler = logging.Handler(None)
    log_handler.add_sink(logging.StdoutSink())
    log = logging.Logger(log_handler)
    log.info("Starting up", None)

    state = 0

    def _on_connect(c: Client, e: ?Exception):
        log.info("on_connect called", {"state": state, "e": e})
        if e is not None:
            log.debug("Failed to connect", {"e": e, "state": state})
            if state == 1:
                c.restart()
            elif state == 2:
                env.exit(0)
        else:
            log.info("Connected successfully", {"state": state})
            state += 1

    def _on_receive(c: Client, data: bytes):
        log.info("Received data: {data}")

    c = Client(env.auth,
                on_connect=_on_connect,
                on_receive=_on_receive,
                address=test_address,
                username=test_username,
                key=None,
                password=test_password,
                port=test_port,
                skip_host_key_check=True,
                log_handler=log_handler)
