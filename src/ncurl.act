#!/usr/bin/env acton
"""ncurl - NETCONF URL tool

A command-line tool for interacting with NETCONF devices, like curl but for
NETCONF. Maybe one day we'll do RESTCONF and gNMI (the other YANG-based
transports), and then we'll be network curl.
"""

import argparse
import file
import logging
import netconf
import xml


def _check_rpc_error(result: ?xml.Node) -> ?str:
    """Check for RPC errors in a NETCONF response.

    Returns None if no errors, or an error message string if errors found.
    """
    if result is not None:
        if result.tag != "rpc-reply":
            return "Invalid response: expected rpc-reply, got {result.tag}"

        for child in result.children:
            if child.tag == "rpc-error":
                error_details = []
                for error_child in child.children:
                    if error_child.tag == "error-message" and error_child.text is not None:
                        error_details.append("message: {error_child.text}")
                    elif error_child.tag == "error-tag" and error_child.text is not None:
                        error_details.append("tag: {error_child.text}")
                    elif error_child.tag == "error-type" and error_child.text is not None:
                        error_details.append("type: {error_child.text}")
                return ', '.join(error_details) if len(error_details) > 0 else "Unknown error"
    else:
        return "No response received"


actor CmdListSchemas(env, args, log_handler):
    """List available schemas from a NETCONF server"""

    host = args.get_str("host")
    port = args.get_int("port")
    username = args.get_str("username")
    password = args.get_str("password")

    var schemas_found = []

    def _on_connect(c: netconf.Client, e: ?Exception):
        if e is not None:
            print("Error: Failed to connect: {e}", err=True)
            env.exit(1)
        else:
            c.list_schemas(_on_list_schemas)

    def _on_list_schemas(c: netconf.Client, schemas: list[(identifier: ?str, namespace: ?str, version: ?str, format: ?str)]):
        for schema in schemas:
            schemas_found.append(schema)

        def _close_cb():
            _display_schemas()

        c.close(_close_cb)

    def _display_schemas():
        print("Available schemas:")
        print("==================")
        count = 0
        for schema in schemas_found:
            version_str = str(schema.version) if schema.version is not None else "N/A"
            format_str = str(schema.format) if schema.format is not None else "N/A"
            identifier_str = str(schema.identifier) if schema.identifier is not None else "N/A"
            namespace_str = str(schema.namespace) if schema.namespace is not None else "N/A"
            print("  {identifier_str:<40} {version_str:<15} {format_str:<5} {namespace_str}")
            count += 1

        print("\nTotal schemas: {count}")
        env.exit(0)

    c = netconf.Client(env.auth,
                      on_connect=_on_connect,
                      on_notif=None,
                      address=host,
                      username=username,
                      key=None,
                      password=password,
                      port=port,
                      log_handler=log_handler)


actor CmdGetConfig(env, args, log_handler):
    """Get configuration from a NETCONF server"""

    host = args.get_str("host")
    port = args.get_int("port")
    username = args.get_str("username")
    password = args.get_str("password")
    source = args.get_str("source")
    filter_subtree = args.get_str("filter-subtree")
    filter_xpath = args.get_str("filter-xpath")
    xpath_namespaces = args.get_strlist("xpath-namespaces")
    output_file = args.get_str("output")

    def _on_connect(c: netconf.Client, e: ?Exception):
        if e is not None:
            print("Error: Failed to connect: {e}", err=True)
            env.exit(1)

        # Build filter if provided
        filter_node: ?xml.Node = None

        if filter_subtree != "" and filter_xpath != "":
            print("Error: Cannot specify both filter-subtree and filter-xpath", err=True)
            env.exit(1)

        if filter_subtree != "":
            # Wrap subtree filter in <filter> element
            try:
                subtree_node = xml.decode(filter_subtree)
                filter_node = xml.Node("filter", attributes=[("type", "subtree")], children=[subtree_node], text=None)
            except xml.XmlParseError as parse_error:
                print("Error: Invalid subtree filter XML: {parse_error.error_message}", err=True)
                env.exit(1)
        elif filter_xpath != "":
            # Create XPath filter with proper namespace
            filter_attrs = [("type", "xpath"), ("select", filter_xpath)]

            # Add namespace declarations if provided
            # Each namespace should be in format "prefix=uri"
            nsdefs = []
            for ns_decl in xpath_namespaces:
                parts = ns_decl.split("=")
                if len(parts) == 2:
                    prefix = parts[0].strip()
                    uri = parts[1].strip()
                    nsdefs.append((prefix, uri))
                else:
                    print("Error: Invalid namespace format '{ns_decl}'. Use prefix=uri", err=True)
                    env.exit(1)

            filter_node = xml.Node("filter", nsdefs, attributes=filter_attrs)

        c.get_config(_on_get_config, source, filter_node)

    def _on_get_config(c: netconf.Client, result: ?xml.Node):
        # Check for errors
        error_msg = _check_rpc_error(result)
        if error_msg is not None:
            print("Error getting config: {error_msg}", err=True)
            env.exit(1)

        # Extract data element
        config_data: ?xml.Node = None
        if result is not None:
            for child in result.children:
                if child.tag == "data":
                    config_data = child
                    break

        config_xml = ""
        if config_data is not None:
            # Extract just the configuration data content
            if len(config_data.children) > 0:
                # Encode children of data element
                for data_child in config_data.children:
                    config_xml += data_child.encode()
            elif config_data.text is not None:
                # If data element has text content
                config_xml = str(config_data.text)
        else:
            print("No data element in response", err=True)
            env.exit(1)

        if output_file != "":
            # Write to file
            f = file.WriteFile(file.WriteFileCap(file.FileCap(env.auth)), output_file)
            f.write(config_xml.encode())
            f.close()
            print("Configuration saved to: {output_file}")
        else:
            # Print to stdout
            print(config_xml)

        def _close_cb():
            env.exit(0)
        c.close(_close_cb)

    c = netconf.Client(env.auth,
                      on_connect=_on_connect,
                      on_notif=None,
                      address=host,
                      username=username,
                      key=None,
                      password=password,
                      port=port,
                      log_handler=log_handler)


actor CmdGetSchema(env, args, log_handler):
    """Download schema(s) from a NETCONF server"""

    host = args.get_str("host")
    port = args.get_int("port")
    username = args.get_str("username")
    password = args.get_str("password")
    identifier_str = args.get_str("identifier")
    version_str = args.get_str("version")
    version = version_str if version_str != "" else None
    format = args.get_str("format")
    output_dir = args.get_str("output-dir")

    var schemas_to_download: list[(identifier: ?str, version: ?str, format: ?str)]= []
    var current_download_index = 0
    var client: ?netconf.Client = None

    def _on_connect(c: netconf.Client, e: ?Exception):
        if e is not None:
            print("Error: Failed to connect: {e}", err=True)
            env.exit(1)
        else:
            client = c
            if identifier_str == "all":
                # First get the list of schemas
                c.list_schemas(_on_list_schemas_for_download)
            else:
                # Download single schema
                schemas_to_download.append((identifier=identifier_str, version=version, format=format))
                _download_next_schema()

    def _on_list_schemas_for_download(c: netconf.Client, schemas: list[(identifier: ?str, namespace: ?str, version: ?str, format: ?str)]):
        # Only download yang format (not yin) to avoid duplicates
        for schema in schemas:
            # Only add schemas with valid identifiers and yang format
            if schema.identifier is not None and schema.format == "yang":
                schemas_to_download.append((identifier=schema.identifier, version=version, format=schema.format))

        print("Found {len(schemas_to_download)} schemas to download")
        _download_next_schema()

    def _download_next_schema():
        if current_download_index >= len(schemas_to_download):
            print("\nAll schemas downloaded successfully!")
            _close_and_exit()
        else:
            schema = schemas_to_download[current_download_index]

            schema_identifier = schema.identifier
            if schema_identifier is None:
                print("Skipping schema with no identifier")
                current_download_index += 1
                _download_next_schema()
                ident = ""
                return
            ident = schema_identifier if schema_identifier is not None else ""

            print("Downloading [{current_download_index + 1}/{len(schemas_to_download)}]: {schema.identifier}")

            c = client
            if c is not None:
                # Use "yang" as default format if not specified
                format_str = schema.format if schema.format is not None else "yang"
                c.get_schema(_on_get_schema, ident, schema.version, format_str)

    def _on_get_schema(c: netconf.Client, result: ?xml.Node):
        if current_download_index < len(schemas_to_download):
            schema = schemas_to_download[current_download_index]

            # Check for errors
            error_msg = _check_rpc_error(result)
            if error_msg is not None:
                print("  Error downloading {schema.identifier}: {error_msg}", err=True)
            else:
                # Extract schema data
                schema_data: ?str = None
                if result is not None:
                    for child in result.children:
                        if child.tag == "data":
                            schema_data = child.text
                            break

                if schema_data is not None:
                    # Build proper filename with identifier and version
                    # We already ensure identifier is not None before getting here
                    filename = "{schema.identifier}"
                    if schema.version is not None:
                        filename = "{schema.identifier}@{schema.version}"
                    if schema.format is not None:
                        filename = "{filename}.{schema.format}"
                    else:
                        filename = "{filename}.yang"

                    if output_dir not in {"", "."}:
                        fs = file.FS(file.FileCap(env.auth))
                        try:
                            await async fs.mkdir(output_dir)
                        except OSError as err:
                            if "already exists" not in err.error_message:
                                raise err
                        filepath = file.join_path([output_dir, filename])
                    else:
                        filepath = filename

                    # Write to file
                    f = file.WriteFile(file.WriteFileCap(file.FileCap(env.auth)), filepath)
                    f.write(schema_data.encode())
                    f.close()
                    print("  Saved to: {filepath}")
                else:
                    print("  Warning: No data received for {schema.identifier}")

        # Move to next schema
        current_download_index += 1
        _download_next_schema()

    def _close_and_exit():
        c = client
        if c is not None:
            def _close_cb():
                env.exit(0)
            c.close(_close_cb)
        else:
            env.exit(0)

    # Connect and start the download process
    netconf.Client(env.auth,
                  on_connect=_on_connect,
                  on_notif=None,
                  address=host,
                  username=username,
                  key=None,
                  password=password,
                  port=port,
                  log_handler=log_handler)


actor main(env):
    logh = logging.Handler()

    def cmd_list_schemas(args):
        """Command handler for list-schemas"""
        if args.get_bool("verbose"):
            logh.set_output_level(logging.TRACE)
            logh.add_sink(logging.ConsoleSink())
        CmdListSchemas(env, args, logh)

    def cmd_get_config(args):
        """Command handler for get-config"""
        if args.get_bool("verbose"):
            logh.set_output_level(logging.TRACE)
            logh.add_sink(logging.ConsoleSink())
        CmdGetConfig(env, args, logh)

    def cmd_get_schema(args):
        """Command handler for get-schema"""
        if args.get_bool("verbose"):
            logh.set_output_level(logging.TRACE)
            logh.add_sink(logging.ConsoleSink())
        CmdGetSchema(env, args, logh)

    def _parse_args():
        p = argparse.Parser()

        # Global options
        p.add_option("host", "str", "?", "localhost", "NETCONF server hostname")
        p.add_option("port", "int", "?", 42830, "NETCONF server port")
        p.add_option("username", "str", "?", "admin", "Username for authentication")
        p.add_option("password", "str", "?", "admin", "Password for authentication")
        p.add_bool("verbose", "Verbose logging from SSH / NETCONF client")

        # Commands
        p_list_schemas = p.add_cmd("list-schemas", "List available schemas", cmd_list_schemas)

        p_get_config = p.add_cmd("get-config", "Get configuration from NETCONF server", cmd_get_config)
        p_get_config.add_option("source", "str", "?", "running", "Configuration datastore (running, startup, candidate)")
        p_get_config.add_option("filter-subtree", "str", "?", "", "XML subtree filter")
        p_get_config.add_option("filter-xpath", "str", "?", "", "XPath expression for filtering")
        p_get_config.add_option("xpath-namespaces", "strlist", "*", [], "Namespace declarations for XPath filtering (format: prefix=uri)")
        p_get_config.add_option("output", "str", "?", "", "Output file (if not specified, prints to stdout)")

        p_get_schema = p.add_cmd("get-schema", "Download schema(s) from NETCONF server", cmd_get_schema)
        p_get_schema.add_arg("identifier", "Schema identifier or 'all' to download all schemas", True, "?")
        p_get_schema.add_option("version", "str", "?", "", "Schema version")
        p_get_schema.add_option("format", "str", "?", "yang", "Schema format (yang or yin)")
        p_get_schema.add_option("output-dir", "str", "?", "schemas", "Output directory for downloaded schemas")

        return p.parse(env.argv)

    try:
        args = _parse_args()
        cmd = args.cmd
        if cmd is not None:
            cmd(args)
        else:
            env.exit(0)
    except argparse.ArgumentError as exc:
        print(str(exc), err=True)
        env.exit(1)
