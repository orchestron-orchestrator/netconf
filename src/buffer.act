import testing


class IncompleteReadError(Exception):
    def __init__(self):
        self.error_message = "Not enough data to read from buffer"
        self.msg = "Not enough data to read from buffer"

class Buffer(object):
    @property
    parts: list[bytes]
    @property
    i: int
    @property
    j: int
    @property
    total_bytes: int
    @property
    unread_bytes: int

    def __init__(self):
        self.parts = []
        self.i = 0
        self.j = 0
        self.total_bytes = 0
        self.unread_bytes = 0

    def write_bytes(self, data: bytes):
        l = len(data)
        self.parts.append(data)
        self.total_bytes += l
        self.unread_bytes += l

    def write_str(self, data: str):
        self.write_bytes(data.encode())

    def consume(self):
        #print("CONSUME!", self.i, self.j)
        if self.i > 0:
            # TODO: use a queue rather then list, i.e. parts: queue[bytes] to avoid copying/moving all elements in list
            self.parts = self.parts[self.i:]
            self.i = 0
        if self.j > 0:
            if len(self.parts) > 0:
                #self.parts[0] = self.parts[0][self.j:]
                parts: list[bytes] = self.parts # Workaround type-checker bug?
                parts[0] = parts[0][self.j:]
            self.j = 0
        self.total_bytes = self.unread_bytes
        #print("CONSUMED!", self.parts)

    def rewind(self):
        #print("REWIND!")
        self.i = 0
        self.j = 0
        self.unread_bytes = self.total_bytes

    def read_bytes_count(self) -> int:
        return self.total_bytes - self.unread_bytes

    def has_unread_bytes(self) -> bool:
        return self.unread_bytes > 0

    def assert_unread_bytes(self, count: int) -> value: # (bool | IncompleteReadError)
        # if self.unread_bytes < count:
        #     raise IncompleteReadError()
        if self.unread_bytes < count:
            return IncompleteReadError()
        else:
            return True

    def read_bytes(self, count: int) -> bytes: # (bytes | IncompleteReadError)
        #print("READ", count)
        #print("READ0!", self.i, self.j)
        if count > self.unread_bytes:
            raise IncompleteReadError()
        remaining = count
        acc = []
        parts: list[bytes] = self.parts # Workaround type-checker bug?
        while remaining > 0:
            #part = self.parts[self.i]
            part = parts[self.i]
            next_j = self.j + remaining
            chunk = part[self.j:next_j]
            chunk_len = len(chunk)
            remaining -= chunk_len
            if next_j >= len(part):
                self.i += 1
                next_j = 0
            self.j = next_j
            acc.append(chunk)
        self.unread_bytes -= count
        #print("READ1!", self.i, self.j)
        return bytes([]).join(acc)

    def read_all_bytes(self) -> bytes:
        b = self.read_bytes(self.unread_bytes)
        if isinstance(b, bytes):
            return b
        else:
            return bytes([])

    def skip_bytes(self, count: int) -> value: # (bool | IncompleteReadError):
        #print("SKIP", count)
        #print("SKIP0!", self.i, self.j)
        if count > self.unread_bytes:
            return IncompleteReadError()
        remaining = count
        parts: list[bytes] = self.parts # Workaround type-checker bug?
        while remaining > 0:
            #part = self.parts[self.i]
            part = parts[self.i]
            part_len = len(part)
            part_remain = part_len - self.j
            if remaining < part_remain:
                self.j += remaining
                break
            remaining -= part_remain
            self.i += 1
            self.j = 0
        self.unread_bytes -= count
        #print("SKIP0!", self.i, self.j)
        return True

    def find_bytes(self, pattern: bytes) -> value: # (index: int | err: IncompleteReadError)
        pattern_len = len(pattern)
        if pattern_len == 0:
            return 0
        elif pattern_len > self.unread_bytes:
            return IncompleteReadError()

        index = 0   # tracks the possible start of pattern
        _i = self.i # current part (index of self.parts)
        _j = self.j # current position in current part

        # Check if we have any parts to search
        if len(self.parts) == 0 or _i >= len(self.parts):
            return IncompleteReadError()

        part = self.parts[_i]
        part_len = len(part)
        while index <= self.unread_bytes - pattern_len:
            pattern_index = 0
            scan_i = _i
            scan_j = _j
            scan_part = part
            scan_part_len = part_len
            # Starting from index, scan the next pattern_len bytes for a pattern match
            while pattern_index < pattern_len:
                b = scan_part[scan_j]
                if b != pattern[pattern_index]:
                    break
                pattern_index += 1
                scan_j += 1
                if scan_j >= scan_part_len:
                    scan_i += 1
                    scan_j = 0
                    if scan_i >= len(self.parts):
                        # We've run out of parts while scanning
                        break
                    scan_part = self.parts[scan_i]
                    scan_part_len = len(scan_part)

            if pattern_index == pattern_len:
                # We matched all bytes in the pattern
                return index

            index += 1
            _j += 1
            if _j >= part_len:
                _i += 1
                _j = 0
                if _i >= len(self.parts):
                    return IncompleteReadError()
                part = self.parts[_i]
                part_len = len(part)

        return IncompleteReadError()

    def match_bytes(self, pattern: bytes) -> value: # (is_match: bool | err: IncompleteReadError)
        b = self.read_bytes(len(pattern))
        if isinstance(b, bytes):
            return b == pattern
        else:
            return b

def _test_buffer_find_bytes_start():
    """Test finding 'hello' at beginning of buffer"""
    buf = Buffer()
    buf.write_str("hello world, this is bob")
    result = buf.find_bytes("hello".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 0, "Should find 'hello' at position 0")


def _test_buffer_find_bytes_mid():
    """Test finding 'world' in middle of buffer"""
    buf = Buffer()
    buf.write_str("hello world, this is bob")
    result = buf.find_bytes("world".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 6, "Should find 'world' at position 6")


def _test_buffer_find_bytes_end():
    """Test finding 'world' in middle of buffer"""
    buf = Buffer()
    buf.write_str("hello world, this is bob")
    result = buf.find_bytes("bob".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 21, "Should find 'bob' at position 21")


def _test_buffer_find_bytes_one():
    """Test finding space character in buffer"""
    buf = Buffer()
    buf.write_str("hello world")
    result = buf.find_bytes(" ".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 5, "Should find space at position 5")


def _test_buffer_find_bytes_not_found():
    """Test pattern not found returns IncompleteReadError"""
    buf = Buffer()
    buf.write_str("hello world")
    result = buf.find_bytes("xyz".encode())
    testing.assertTrue(isinstance(result, IncompleteReadError), "Should return IncompleteReadError for non-existent pattern")


# Test overlapping patterns

def _test_buffer_find_bytes_separator_single_bracket():
    """Test finding NETCONF separator preceded by single ]"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]]]>]]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 1, "Should find separator at position 1 after single ]")


def _test_buffer_find_bytes_separator_double_bracket():
    """Test finding NETCONF separator preceded by double ]]"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]]]]>]]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 2, "Should find separator at position 2 after double ]]")


def _test_buffer_find_bytes_separator_mixed_prefix():
    """Test finding NETCONF separator preceded by ]>]"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]>]]]>]]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 3, "Should find separator at position 3 after ]>]")


def _test_buffer_find_bytes_split_across_two_parts():
    """Test finding pattern split across two buffer parts"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("data]]")
    buf.write_str(">]]>more")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 4, "Should find separator split across parts")


def _test_buffer_find_bytes_split_with_overlap():
    """Test finding pattern with overlapping character before split"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("data]")
    buf.write_str("]]>]]>more")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 5, "Should find separator with ] before split")


def _test_buffer_find_bytes_across_three_parts():
    """Test finding pattern split across 3 buffer parts"""
    buf = Buffer()
    buf.write_str("ab")
    buf.write_str("cd")
    buf.write_str("ef")
    result = buf.find_bytes("cde".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 2, "Should find pattern across 3 parts")


def _test_buffer_find_bytes_separator_four_parts():
    """Test finding NETCONF separator split across 4 parts"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]")
    buf.write_str("]>")
    buf.write_str("]")
    buf.write_str("]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 0, "Should find separator split across 4 parts")


def _test_buffer_find_bytes_empty_pattern():
    """Test finding empty pattern returns 0"""
    buf = Buffer()
    buf.write_str("test")
    result = buf.find_bytes("".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for empty pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 0, "Empty pattern should return 0")


def _test_buffer_find_bytes_pattern_too_long():
    """Test pattern longer than buffer returns IncompleteReadError"""
    buf = Buffer()
    buf.write_str("short")
    result = buf.find_bytes("very long pattern".encode())
    testing.assertTrue(isinstance(result, IncompleteReadError), "Pattern longer than buffer should return IncompleteReadError")


def _test_buffer_find_bytes_pattern_at_end():
    """Test finding pattern at the very end of buffer"""
    buf = Buffer()
    buf.write_str("data]]>]]>")
    result = buf.find_bytes("]]>]]>".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 4, "Should find pattern at end of buffer")


def _test_buffer_find_bytes_first_separator():
    """Test finding first separator in buffer"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("first]]>]]>second]]>]]>third")
    pos = buf.find_bytes(separator)
    testing.assertTrue(isinstance(pos, int), "Should return int for found pattern")
    if isinstance(pos, int):
        testing.assertEqual(pos, 5, "Should find first separator at position 5")


def _test_buffer_find_bytes_after_consume():
    """Test finding separator after consume operation"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("first]]>]]>second]]>]]>third")

    # Find and skip past first separator
    pos = buf.find_bytes(separator)
    if isinstance(pos, int):
        skip_result = buf.skip_bytes(pos + len(separator))
        if isinstance(skip_result, bool):
            buf.consume()

            # Find second separator
            pos2 = buf.find_bytes(separator)
            testing.assertTrue(isinstance(pos2, int), "Should return int for found pattern")
            if isinstance(pos2, int):
                testing.assertEqual(pos2, 6, "Should find second separator at position 6 after consume")
