import testing


class IncompleteReadError(Exception):
    def __init__(self):
        self.error_message = "Not enough data to read from buffer"
        self.msg = "Not enough data to read from buffer"


class Buffer(object):
    data: bytes
    read_pos: int
    total_bytes: int
    unread_bytes: int

    def __init__(self):
        self.data = bytes([])
        self.read_pos = 0
        self.total_bytes = 0
        self.unread_bytes = 0

    def write_bytes(self, data: bytes):
        l = len(data)
        self.data = self.data + data
        self.total_bytes += l
        self.unread_bytes += l

    def write_str(self, data: str):
        self.write_bytes(data.encode())

    def consume(self):
        if self.read_pos > 0:
            self.data = self.data[self.read_pos:]
            self.read_pos = 0
        self.total_bytes = self.unread_bytes

    def rewind(self):
        self.read_pos = 0
        self.unread_bytes = self.total_bytes

    def read_bytes_count(self) -> int:
        return self.total_bytes - self.unread_bytes

    def has_unread_bytes(self) -> bool:
        return self.unread_bytes > 0

    def assert_unread_bytes(self, count: int) -> value:
        if self.unread_bytes < count:
            return IncompleteReadError()
        else:
            return True

    def read_bytes(self, count: int) -> bytes:
        if count > self.unread_bytes:
            raise IncompleteReadError()
        end_pos = self.read_pos + count
        result = self.data[self.read_pos:end_pos]
        self.read_pos = end_pos
        self.unread_bytes -= count
        return result

    def read_all_bytes(self) -> bytes:
        b = self.read_bytes(self.unread_bytes)
        if isinstance(b, bytes):
            return b
        else:
            return bytes([])

    def skip_bytes(self, count: int) -> value:
        if count > self.unread_bytes:
            return IncompleteReadError()
        self.read_pos += count
        self.unread_bytes -= count
        return True

    def find_bytes(self, pattern: bytes) -> value:
        pattern_len = len(pattern)
        if pattern_len == 0:
            return 0
        elif pattern_len > self.unread_bytes:
            return IncompleteReadError()

        # Search from current read position to end
        search_end = self.read_pos + self.unread_bytes
        pos = self.data.find(pattern, self.read_pos, search_end)

        if pos >= 0:
            # Return relative position from current read position
            return pos - self.read_pos
        else:
            return IncompleteReadError()

    def match_bytes(self, pattern: bytes) -> value:
        b = self.read_bytes(len(pattern))
        if isinstance(b, bytes):
            return b == pattern
        else:
            return b


def _test_buffer_find_bytes_start():
    """Test finding 'hello' at beginning of buffer"""
    buf = Buffer()
    buf.write_str("hello world, this is bob")
    result = buf.find_bytes("hello".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 0, "Should find 'hello' at position 0")


def _test_buffer_find_bytes_mid():
    """Test finding 'world' in middle of buffer"""
    buf = Buffer()
    buf.write_str("hello world, this is bob")
    result = buf.find_bytes("world".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 6, "Should find 'world' at position 6")


def _test_buffer_find_bytes_end():
    """Test finding 'world' in middle of buffer"""
    buf = Buffer()
    buf.write_str("hello world, this is bob")
    result = buf.find_bytes("bob".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 21, "Should find 'bob' at position 21")


def _test_buffer_find_bytes_one():
    """Test finding space character in buffer"""
    buf = Buffer()
    buf.write_str("hello world")
    result = buf.find_bytes(" ".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 5, "Should find space at position 5")


def _test_buffer_find_bytes_not_found():
    """Test pattern not found returns IncompleteReadError"""
    buf = Buffer()
    buf.write_str("hello world")
    result = buf.find_bytes("xyz".encode())
    testing.assertTrue(isinstance(result, IncompleteReadError), "Should return IncompleteReadError for non-existent pattern")


# Test overlapping patterns

def _test_buffer_find_bytes_separator_single_bracket():
    """Test finding NETCONF separator preceded by single ]"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]]]>]]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 1, "Should find separator at position 1 after single ]")


def _test_buffer_find_bytes_separator_double_bracket():
    """Test finding NETCONF separator preceded by double ]]"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]]]]>]]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 2, "Should find separator at position 2 after double ]]")


def _test_buffer_find_bytes_separator_mixed_prefix():
    """Test finding NETCONF separator preceded by ]>]"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]>]]]>]]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 3, "Should find separator at position 3 after ]>]")


def _test_buffer_find_bytes_split_across_two_parts():
    """Test finding pattern split across two buffer parts"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("data]]")
    buf.write_str(">]]>more")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 4, "Should find separator split across parts")


def _test_buffer_find_bytes_split_with_overlap():
    """Test finding pattern with overlapping character before split"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("data]")
    buf.write_str("]]>]]>more")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 5, "Should find separator with ] before split")


def _test_buffer_find_bytes_across_three_parts():
    """Test finding pattern split across 3 buffer parts"""
    buf = Buffer()
    buf.write_str("ab")
    buf.write_str("cd")
    buf.write_str("ef")
    result = buf.find_bytes("cde".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 2, "Should find pattern across 3 parts")


def _test_buffer_find_bytes_separator_four_parts():
    """Test finding NETCONF separator split across 4 parts"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("]")
    buf.write_str("]>")
    buf.write_str("]")
    buf.write_str("]>")
    result = buf.find_bytes(separator)
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 0, "Should find separator split across 4 parts")


def _test_buffer_find_bytes_empty_pattern():
    """Test finding empty pattern returns 0"""
    buf = Buffer()
    buf.write_str("test")
    result = buf.find_bytes("".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for empty pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 0, "Empty pattern should return 0")


def _test_buffer_find_bytes_pattern_too_long():
    """Test pattern longer than buffer returns IncompleteReadError"""
    buf = Buffer()
    buf.write_str("short")
    result = buf.find_bytes("very long pattern".encode())
    testing.assertTrue(isinstance(result, IncompleteReadError), "Pattern longer than buffer should return IncompleteReadError")


def _test_buffer_find_bytes_pattern_at_end():
    """Test finding pattern at the very end of buffer"""
    buf = Buffer()
    buf.write_str("data]]>]]>")
    result = buf.find_bytes("]]>]]>".encode())
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, 4, "Should find pattern at end of buffer")


def _test_buffer_find_bytes_first_separator():
    """Test finding first separator in buffer"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("first]]>]]>second]]>]]>third")
    pos = buf.find_bytes(separator)
    testing.assertTrue(isinstance(pos, int), "Should return int for found pattern")
    if isinstance(pos, int):
        testing.assertEqual(pos, 5, "Should find first separator at position 5")


def _test_buffer_find_bytes_after_consume():
    """Test finding separator after consume operation"""
    buf = Buffer()
    separator = "]]>]]>".encode()
    buf.write_str("first]]>]]>second]]>]]>third")

    # Find and skip past first separator
    pos = buf.find_bytes(separator)
    if isinstance(pos, int):
        skip_result = buf.skip_bytes(pos + len(separator))
        if isinstance(skip_result, bool):
            buf.consume()

            # Find second separator
            pos2 = buf.find_bytes(separator)
            testing.assertTrue(isinstance(pos2, int), "Should return int for found pattern")
            if isinstance(pos2, int):
                testing.assertEqual(pos2, 6, "Should find second separator at position 6 after consume")


def _test_buffer_find_bytes_performance():
    """Test performance of finding pattern at end of large buffer with 64k chunks"""

    buf = Buffer()
    pattern = "]]>]]>".encode()
    chunk_size = 64 * 1024  # 64KB chunks
    total_size = 2 * 1024 * 1024  # 2MB total

    # Create a chunk of data that doesn't contain the pattern
    chunk_data = ("x" * chunk_size).encode()

    # Write chunks to buffer (2MB total) and search after each chunk
    num_chunks = total_size // chunk_size
    for i in range(num_chunks):
        buf.write_bytes(chunk_data)
        # Search for pattern after each chunk (should not be found)
        result = buf.find_bytes(pattern)
        testing.assertTrue(isinstance(result, IncompleteReadError), f"Should not find pattern after chunk {i+1}")

    # Add pattern at the very end
    buf.write_str("]]>]]>")

    # Now search for pattern (should be found at end)
    result = buf.find_bytes(pattern)

    # Verify pattern was found at correct position
    testing.assertTrue(isinstance(result, int), "Should return int for found pattern")
    if isinstance(result, int):
        testing.assertEqual(result, total_size, "Should find pattern at position 2MB")
